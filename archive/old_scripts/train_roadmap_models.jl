#!/usr/bin/env julia

"""
    train_roadmap_models.jl

Strict, roadmap-aligned training for UDE and BNode on per-scenario data.

Equations (roadmap):
  Eq1: dx1/dt = Œ∑in * u+(t) - (1/Œ∑out) * u‚àí(t) - d(t)            # physics-only
  Eq2: dx2/dt = -Œ± x2 + fŒ∏(Pgen) - Œ≤*Pload + Œ≥ * x1              # NN replaces only Œ≤¬∑Pgen

Inputs required in CSVs: time, x1, x2, u, d, Pgen, Pload, scenario
Files used: data/training_roadmap.csv (and val/test for later evaluation)
"""

using Pkg
Pkg.activate(".")

push!(LOAD_PATH, joinpath(@__DIR__, "..", "src"))

using DifferentialEquations
using Optim
using Statistics
using CSV
using DataFrames
using BSON
using Random

println("üöÄ ROADMAP-ALIGNED TRAINING (per-scenario)")
println("=" ^ 70)

# -----------------------------------------------------------------------------
# Load training data (generated by scripts/generate_roadmap_dataset.jl)
# -----------------------------------------------------------------------------
train_path = joinpath(@__DIR__, "..", "data", "training_roadmap.csv")
if !isfile(train_path)
    error("Missing training data: $(train_path). Run scripts/generate_roadmap_dataset.jl first.")
end

df = CSV.read(train_path, DataFrame)
@assert all([:time, :x1, :x2, :u, :u_plus, :u_minus, :I_u_pos, :I_u_neg, :d, :Pgen, :Pload, :scenario] .‚àà names(df)) "Dataset missing required columns"

println("  ‚Üí Loaded $(nrow(df)) rows across $(length(unique(df.scenario))) scenarios")

# Group rows per scenario and keep time-sorted
function group_scenarios(df::DataFrame)
    groups = Dict{String, DataFrame}()
    for sub in groupby(df, :scenario)
        s = only(unique(sub.scenario))
        groups[string(s)] = sort(sub, :time)
    end
    return groups
end

sc_to_df = group_scenarios(df)
scenarios = collect(keys(sc_to_df))
println("  ‚Üí Scenarios: $(length(scenarios))")

# -----------------------------------------------------------------------------
# Neural architecture: fŒ∏(Pgen) ‚Üí ‚Ñù (scalar) - CORRECTED per SS
# 1 ‚Üí 5 (tanh) ‚Üí 1 (sum); 10 parameters
# -----------------------------------------------------------------------------
function ftheta(Pgen::Float64, params::AbstractVector{<:Real})
    Œ∏ = params
    W1 = reshape(Œ∏[1:5], 5, 1)
    b1 = Œ∏[6:10]
    h = tanh.(W1 * [Pgen] .+ b1)
    return sum(h)
end

# Physics parameters: Œ∑in, Œ∑out, Œ±, Œ≤, Œ≥ (5 params) - ADDED Œ≤
# Total parameter vector: [Œ∑in, Œ∑out, Œ±, Œ≤, Œ≥, Œ∏...] with Œ∏ length 10

# RHS builder that closes over exogenous signals of a scenario
function make_rhs_scenario(params::AbstractVector{<:Real}, T::Vector{Float64}, u_plus, u_minus, I_u_pos, I_u_neg, d_sig, Pgen_sig, Pload_sig)
    function rhs!(du, x, p, t)
        x1, x2 = x
        idx = clamp(searchsortedlast(T, t), 1, length(T))
        up_t, um_t = u_plus[idx], u_minus[idx]
        Ipos_t, Ineg_t = I_u_pos[idx], I_u_neg[idx]
        d_t = d_sig[idx]
        Pgen_t, Pload_t = Pgen_sig[idx], Pload_sig[idx]
        Œ∑in, Œ∑out, Œ±, Œ≤, Œ≥ = params[1:5]  # ADDED Œ≤
        Œ∏ = params[6:end]  # Œ∏ now starts at index 6
        du[1] = Œ∑in * up_t * Ipos_t - (1/Œ∑out) * um_t * Ineg_t - d_t
        du[2] = -Œ± * x2 + ftheta(Pgen_t, Œ∏) - Œ≤ * Pload_t + Œ≥ * x1  # CORRECTED per SS
    end
    return rhs!
end

# Scenario loss: simulate from scenario's first state and MSE vs (x1,x2)
function scenario_loss(params::AbstractVector{<:Real}, sdata::DataFrame)
    T = Vector{Float64}(sdata.time)
    Y = Matrix(sdata[:, [:x1, :x2]])
    u_plus_sig = Vector{Float64}(sdata.u_plus)
    u_minus_sig = Vector{Float64}(sdata.u_minus)
    I_u_pos_sig = Vector{Float64}(sdata.I_u_pos)
    I_u_neg_sig = Vector{Float64}(sdata.I_u_neg)
    d_sig = Vector{Float64}(sdata.d)
    Pgen_sig = Vector{Float64}(sdata.Pgen)
    Pload_sig = Vector{Float64}(sdata.Pload)

    rhs! = make_rhs_scenario(params, T, u_plus_sig, u_minus_sig, I_u_pos_sig, I_u_neg_sig, d_sig, Pgen_sig, Pload_sig)
    x0 = Y[1, :]  # start from first observed state
    prob = ODEProblem(rhs!, x0, (minimum(T), maximum(T)))
    sol = solve(prob, Tsit5(); saveat=T, abstol=1e-6, reltol=1e-6)
    if sol.retcode != :Success
        return Inf
    end
    Yhat = reduce(hcat, (sol(t) for t in T))'
    return mean((Yhat .- Y).^2)
end

# Global loss across scenarios (mean of per-scenario losses)
function total_loss(params::AbstractVector{<:Real})
    losses = Float64[]
    for s in scenarios
        push!(losses, scenario_loss(params, sc_to_df[s]))
    end
    return mean(losses)
end

# Finite-difference gradient (simple, robust)
function fd_grad!(g, p)
    Œµ = 1e-6
    f0 = total_loss(p)
    for i in eachindex(p)
        p[i] += Œµ
        f1 = total_loss(p)
        g[i] = (f1 - f0) / Œµ
        p[i] -= Œµ
    end
    return nothing
end

# Initialize parameters - UPDATED for new structure
Random.seed!(42)
physics0 = [0.9, 0.9, 0.1, 1.0, 0.02]   # Œ∑in, Œ∑out, Œ±, Œ≤, Œ≥ (ADDED Œ≤)
Œ∏0 = 0.1 .* randn(10)  # REDUCED from 15 to 10 (only Pgen input)
params0 = vcat(physics0, Œ∏0)

println("üéØ Initial total loss: ", round(total_loss(params0), digits=6))

# Optimization configuration (UDE)
opt_opts = Optim.Options(iterations=300, show_trace=true, show_every=20, g_tol=1e-6, x_abstol=1e-6, f_reltol=1e-6)
res = Optim.optimize(total_loss, fd_grad!, params0, LBFGS(), opt_opts)

ude_params_opt = res.minimizer
ude_loss_final = res.minimum
ude_converged = Optim.converged(res)

println("‚úÖ UDE converged: ", ude_converged)
println("   Final loss: ", round(ude_loss_final, digits=6))

# Save UDE checkpoint
ckpt_dir = joinpath(@__DIR__, "..", "checkpoints")
if !isdir(ckpt_dir); mkdir(ckpt_dir); end
BSON.@save joinpath(ckpt_dir, "ude_roadmap_opt.bson") ude_params_opt ude_loss_final ude_converged physics0
println("üíæ Saved UDE checkpoint ‚Üí checkpoints/ude_roadmap_opt.bson")

# -----------------------------------------------------------------------------
# Sketch BNode model (Bayesian); defined but not executed here to avoid long runs
# -----------------------------------------------------------------------------
println("üìå BNode (Bayesian) model is defined but sampling is not started in this script.")
println("    - To run, wrap total_loss with a Turing model that parameterizes Œ∏ and physics,")
println("      and uses the per-scenario likelihood from the ODE solutions.") 